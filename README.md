# algo-labs
# lab1
## Рівень 2.

### Варіант 1

Зеник подарував Марічці ділянку городу розміром n на m, поділену на клітинки розміром 1 на 1 метр. У кожній клітинці Марічка посадила гарбузи, щоб дарувати їх залицальникам. Марічка почала садити гарбузи починаючи із верхньої лівої, і при досягненні правої межі - розверталась і рухалась справа наліво, як вказано в прикладі для m x n, де m - кількість рядків, а n - кількість стовпців:

1 2 3 4 
8 7 6 5 
9 10 11 12 
16 15 14 13

Для садіння Марічка вирішила використати робота-садівника, який садить в кожну клітинку задану кількість зернят, які слід вказати як одномірний масив m x n. Якщо Марічка хоче посадити таку кількість гарбузів

1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

Тоді роботу необхідно подати на всід таку послідовність (маршрут робота не незмінним): 

1 2 3 4 8 7 6 5 9 10 11 12 16 15 14 13

 
Реалізуйте алгоритм, який отримає на вхід масив розміром m та n, в кожній клітинці якого знаходиться бажана кількість гарбузів та поверне одномірний масив, скільки зернин має висаджувати робот при руху згідно маршруту, вказаного в цій задчі (маршрут є незмінним)

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` . Ваш тести мають перевірити роботу алгоритму при значеннях m == n == 5, m =2, n =4, n = 1, m = 6


# lab2
## Рівень 2

### Варіант 1 

Love

Андрій закоханий у Ілону. Вони вирішили провести День святого Валентина разом в Ашані, але Андрій, як ми всі знаємо, дуже зайнятий на роботі, тому він не зміг прийти. Тепер якраз Ілона знову наповнена гнівом і готова його вбити. Але є щось, що ви можете зробити.

Андрій розповідає Ілоні, що він програміст-початківець і, як правило, зайнятий вирішенням важливих проблем на проекті. Тож Ілона вирішує перевірити його алгоритмічні навички. Вона пише масив N цілих чисел. Вона дає йому число P і запитує, чи може він знайти три ( тільки три) цілих числа Ai Aj Ak (i ≠ j ≠ k) в масиві, сума якого дорівнює числу P, тобто

Ai + Aj + Ak  = P

Отже, чим швидше Андрій скаже відповідь “Такі числа є” або “Таких чисел немає” тим швидше він отримає поцілунок

Вхідні дані:
Масив цілих чисел A1, A2 A3 ……………. AN 
Р - Шукане число 

Обмеження
3<= N <= 1000
1<= Ai <= 10^9 де 1<= i <=N
1<= P <= 3*10^9

Приклад

Input
1 2 3
6

Output
True

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку `unittest` 

# lab3
## Рівень 2
### Варіант 1

Для бінарного дерева знайдіть суму всіх листків, які є лівими дітьми.

```
    3
   / \
  9  20
    /  \
   15   7
```
Лівий лист цього дерева - 9 та 15, тому сума лівих листів становить 9 + 15 = 24.

Реалізуйте функцію, яка отримує на вхід кореневий вузол дерева, та повертає значення суми `branchSums`: 
```
def branchSums(root):
	pass
```
**Вхідні дані:** Дерево подається у вигляді вузлів, де кожен вузол має ціле значення. Корінь дерева завжди не є лівим листом

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

```
class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```

Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу `BinaryTree` наступним чином:

```
root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
```

# lab4
## Рівень 2
## Варіант 1

Реалізуйте структуру даних "черга з пріоритетами" на основі  бінарної купи  `binary heap`, в якому кожен батьківський елемент має вищий пріоритет, ніж пріоритети його дітей.

Якщо у двох елементів однаковий пріоритет, то батьківський елемент може мати пріоритет, ідентичний пріоритету одного або обох його дітей.

Операції, які підтримує ваша черга:

1. Вставка елемента з заданим значенням та пріоритетом до черги.
2. Видалення та повернення елемента з найвищим пріоритетом з черги.
3. Перегляд черги без її зміни.

Для реалізації такої черги з пріоритетами слід використати окремий клас `Node`, де кожен елемент буде мати два поля: значення та пріоритет. При вставці елемента до черги, його потрібно розмістити у відповідному порядку з урахуванням пріоритету. При видаленні елемента з найвищим пріоритетом, на його місце слід розмістити елемент з наступним найвищим пріоритетом.

Назва файлу реалізації - `heap_based_priority_queue.py`

# lab5

# level 3
Варіант 3 Обчислення кількості островів

Нехай дано двійкову матрицю, де 0 означає воду, а 1 — сушу, а з’єднані числа 1 утворюють острів, підрахуйте загальну кількість островів.

Наприклад, розглянемо таке зображення, де синім позначено воду (0), а сірим - сушу (1):


Загалом у наведеній вище матриці присутні п’ять островів. На зображенні нижче вони позначені цифрами 1–5.

# lab6
# level 3
Важливим фактором для багатокористувацької онлайн-гри є низька мережева затримка
вiд користувача до сервера. При цьому, пристрої в Iнтернетi спiлкуються один з
одним, використовуючи мережевi маршрути, якi проходять через низку промiжних
вузлiв-маршрутизаторiв. Кожна ланка цього маршруту має власну ненульову затримку.

# lab7
# Рівень 2

## Варіант 1

Створити функцію на мові програмування Python, яка приймає дві стрічки: "haystack" (довільний текст) та "needle" (шукана стрічка). Програма повинна знайти  індекси всіх входжень стрічки "needle" в стрічці "haystack" та повернути цей індекс,  використовуючи  метод Рабіна-Карпа для пошуку підстрічки у стрічці




# lab 8
# Рівень 2 

## Варіант 1

До вас звернулась мерія міста Венеції з незвичним проханням. Це місто складається з островів які розділені каналами. Кожен острів має свою унікальну локацію і з'єднаний з іншими островами мостами. Мерія міста хоче провести оптоволоконний інтернет на кожен з островів таким чином, щоб кожен острів був з'єднаний з кожним іншим безпосередньо, або через інші острови. Вам потрібно допомогти порахувати мінімальну довжину кабелів, які потрібно прокласти, щоб відстань між всіма островами була мінімальна.

**Вхідні дані:**

- файл `islands.csv`, який містить матрицю суміжності, де елемент `[i][j]` вказує на відстань між островами `i` та `j`. 

**Вихідні дані:**

- Мінімальна довжина підводних кабелів, які потрібно прокласти.

При виборі алгоритму слід вважати, що кількість островів у місті становить `N (1 ≤ N ≤ 100)`



